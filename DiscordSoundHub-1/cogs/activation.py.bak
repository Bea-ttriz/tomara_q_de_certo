import asyncio
import discord
from discord.ext import commands
import logging
import datetime

# Configura√ß√£o do logger
logger = logging.getLogger('discord_bot.activation')

import os
import json

class Activation(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.is_active = False  # Estado de ativa√ß√£o do bot
        self.activation_task = None  # Tarefa para gerenciar o temporizador
        self.activation_time = None  # Quando o bot foi ativado
        self.default_duration = 7200  # 2 horas em segundos (padr√£o)
        self.activation_duration = self.default_duration
        self.timeout_message_sent = {}  # Para controlar mensagens de timeout por servidor
        self.settings_file = "cogs/activation_settings.json"
        
        # Carregar configura√ß√µes personalizadas
        self.load_settings()
        
        logger.info("Sistema de ativa√ß√£o temporal iniciado")
    
    def cog_unload(self):
        """Chamado quando o cog √© descarregado"""
        if self.activation_task:
            self.activation_task.cancel()
    
    @commands.Cog.listener()
    async def on_ready(self):
        """Configura√ß√£o inicial quando o bot est√° pronto"""
        logger.info("M√≥dulo de ativa√ß√£o inicializado")
        
        # Exibir instru√ß√µes claras ao iniciar
        if not self.is_active:
            logger.info("Bot iniciado em estado desativado")
            for guild in self.bot.guilds:
                # Procurar o primeiro canal de texto em cada servidor
                text_channel = None
                for channel in guild.text_channels:
                    if channel.permissions_for(guild.me).send_messages:
                        text_channel = channel
                        break
                
                if text_channel:
                    try:
                        embed = discord.Embed(
                            title="ü§ñ Bot Iniciado - Desativado",
                            description="O bot foi iniciado, mas est√° atualmente desativado.",
                            color=discord.Color.orange()
                        )
                        embed.add_field(
                            name="Como ativar",
                            value="Voc√™ pode ativar o bot de v√°rias formas:\n"
                                 "- Digite `!ativar` (com o prefixo)\n"
                                 "- Digite apenas `ativar` (sem prefixo)\n"
                                 "- Digite `ativar bot` ou `bot ativar`",
                            inline=False
                        )
                        # Converter para horas
                        duracao_horas = round(self.activation_duration / 3600)
                        embed.add_field(
                            name="Dura√ß√£o",
                            value=f"O bot permanecer√° ativo por {duracao_horas} hora{'s' if duracao_horas > 1 else ''} ap√≥s ser ativado.",
                            inline=False
                        )
                        embed.set_footer(text="Desenvolvido para o servidor rivoTRIO")
                        
                        await text_channel.send(embed=embed)
                        logger.info(f"Mensagem de instru√ß√£o de ativa√ß√£o enviada para {guild.name}")
                    except Exception as e:
                        logger.error(f"Erro ao enviar mensagem de instru√ß√£o: {e}")
    
    async def deactivation_timer(self, ctx):
        """Fun√ß√£o que gerencia o temporizador de desativa√ß√£o"""
        try:
            # Esperar pelo tempo de dura√ß√£o
            await asyncio.sleep(self.activation_duration)
            
            # Depois do tempo, desativar o bot
            self.is_active = False
            self.activation_time = None
            
            # Anunciar que o bot foi desativado por timeout
            try:
                # Preparar a mensagem de timeout
                # Converter segundos para horas para exibi√ß√£o
                duracao_horas = round(self.activation_duration / 3600)
                embed = discord.Embed(
                    title="‚è±Ô∏è Tempo Esgotado",
                    description=f"O bot foi desativado automaticamente ap√≥s {duracao_horas} hora{'s' if duracao_horas > 1 else ''} de uso.",
                    color=discord.Color.red()
                )
                embed.add_field(
                    name="Como reativar",
                    value=self.get_activation_message(),
                    inline=False
                )
                
                # Enviar a mensagem apenas se n√£o houver uma mensagem recente
                guild_id = ctx.guild.id
                if guild_id not in self.timeout_message_sent or self.timeout_message_sent[guild_id] + datetime.timedelta(minutes=10) < datetime.datetime.now():
                    await ctx.send(embed=embed)
                    self.timeout_message_sent[guild_id] = datetime.datetime.now()
                
                # Desconectar de todos os canais de voz
                for voice_client in self.bot.voice_clients:
                    if voice_client.guild.id == ctx.guild.id:
                        await voice_client.disconnect(force=True)
                        logger.info(f"Desconectado do canal de voz em {voice_client.guild.name} ap√≥s timeout")
            
            except Exception as e:
                logger.error(f"Erro ao enviar mensagem de timeout: {e}")
            
            duracao_horas = round(self.activation_duration / 3600)
            logger.info(f"Bot desativado por timeout ap√≥s {duracao_horas} hora(s)")
        
        except asyncio.CancelledError:
            # A tarefa foi cancelada, isso √© normal durante a desativa√ß√£o manual
            logger.info("Timer de desativa√ß√£o cancelado manualmente")
        
        except Exception as e:
            logger.error(f"Erro no timer de desativa√ß√£o: {e}")
    
    @commands.command(name="ativar")
    async def activate_bot(self, ctx):
        """Ativa o bot pelo per√≠odo configurado (padr√£o: 2 horas)"""
        # Log para depura√ß√£o
        logger.info(f"Comando !ativar recebido de {ctx.author.name} no servidor {ctx.guild.name}")
        
        if self.is_active:
            # Mostrar quanto tempo resta
            if self.activation_time:
                elapsed = (datetime.datetime.now() - self.activation_time).total_seconds()
                remaining = max(0, self.activation_duration - elapsed)
                hours, remainder = divmod(int(remaining), 3600)
                minutes, seconds = divmod(remainder, 60)
                
                time_str = ""
                if hours > 0:
                    time_str += f"{hours} hora{'s' if hours > 1 else ''} "
                if minutes > 0 or hours > 0:
                    time_str += f"{minutes} minuto{'s' if minutes != 1 else ''} "
                time_str += f"{seconds} segundo{'s' if seconds != 1 else ''}"
                
                logger.info(f"Bot j√° ativo, tempo restante: {time_str}")
                
                embed = discord.Embed(
                    title="‚úÖ Bot j√° est√° ativo",
                    description=f"O bot j√° est√° ativado e funcionando.",
                    color=discord.Color.green()
                )
                embed.add_field(
                    name="‚è±Ô∏è Tempo restante",
                    value=f"{time_str}",
                    inline=False
                )
                
                await ctx.send(embed=embed)
            else:
                await ctx.send("‚úÖ O bot j√° est√° ativo e funcionando.")
            return
        
        # Ativar o bot
        self.is_active = True
        self.activation_time = datetime.datetime.now()
        
        # Iniciar o temporizador de desativa√ß√£o
        if self.activation_task:
            self.activation_task.cancel()
        self.activation_task = asyncio.create_task(self.deactivation_timer(ctx))
        
        # Informar ao usu√°rio
        duracao_horas = round(self.activation_duration / 3600)
        embed = discord.Embed(
            title="üéµ Bot Ativado",
            description=f"O bot foi ativado com sucesso e ficar√° dispon√≠vel por {duracao_horas} hora{'s' if duracao_horas > 1 else ''}.",
            color=discord.Color.green()
        )
        embed.add_field(
            name="Comandos dispon√≠veis",
            value="`!ajuda` - Para ver todos os comandos\n"
                  "`!tocar <nome>` - Para reproduzir um √°udio\n"
                  "`!listar` - Para ver todos os √°udios dispon√≠veis",
            inline=False
        )
        embed.add_field(
            name="Desativa√ß√£o autom√°tica",
            value=f"O bot ser√° desativado automaticamente ap√≥s {duracao_horas} hora{'s' if duracao_horas > 1 else ''}.",
            inline=False
        )
        
        await ctx.send(embed=embed)
        logger.info(f"Bot ativado por {ctx.author.name} no servidor {ctx.guild.name}")
    
    @commands.command(name="desativar")
    async def deactivate_bot(self, ctx):
        """Desativa o bot manualmente"""
        if not self.is_active:
            await ctx.send("‚ö†Ô∏è O bot j√° est√° desativado.")
            return
        
        # Desativar o bot
        self.is_active = False
        self.activation_time = None
        
        # Cancelar o temporizador se estiver ativo
        if self.activation_task:
            self.activation_task.cancel()
            self.activation_task = None
        
        # Desconectar de todos os canais de voz
        for voice_client in self.bot.voice_clients:
            if voice_client.guild.id == ctx.guild.id:
                await voice_client.disconnect(force=True)
                logger.info(f"Desconectado do canal de voz em {voice_client.guild.name} ap√≥s desativa√ß√£o manual")
        
        # Informar ao usu√°rio
        embed = discord.Embed(
            title="üõë Bot Desativado",
            description="O bot foi desativado manualmente.",
            color=discord.Color.red()
        )
        embed.add_field(
            name="Reativa√ß√£o",
            value=self.get_activation_message(),
            inline=False
        )
        
        await ctx.send(embed=embed)
        logger.info(f"Bot desativado manualmente por {ctx.author.name} no servidor {ctx.guild.name}")
    
    @commands.command(name="status")
    async def check_status(self, ctx):
        """Verifica o status atual do bot (ativo/inativo)"""
        if self.is_active:
            # Calcular tempo restante
            elapsed = (datetime.datetime.now() - self.activation_time).total_seconds()
            remaining = max(0, self.activation_duration - elapsed)
            hours, remainder = divmod(int(remaining), 3600)
            minutes, seconds = divmod(remainder, 60)
            
            time_str = ""
            if hours > 0:
                time_str += f"{hours} hora{'s' if hours > 1 else ''} "
            if minutes > 0 or hours > 0:
                time_str += f"{minutes} minuto{'s' if minutes != 1 else ''} "
            time_str += f"{seconds} segundo{'s' if seconds != 1 else ''}"
            
            embed = discord.Embed(
                title="‚úÖ Bot Ativo",
                description="O bot est√° ativo e pronto para uso.",
                color=discord.Color.green()
            )
            embed.add_field(
                name="‚è±Ô∏è Tempo restante",
                value=f"{time_str}",
                inline=False
            )
            
            # Adicionar informa√ß√µes de uso
            player_cog = self.bot.get_cog('Player')
            if player_cog and ctx.guild.id in player_cog.currently_playing:
                currently_playing = player_cog.currently_playing[ctx.guild.id]
                embed.add_field(
                    name="üéµ Tocando agora",
                    value=f"{currently_playing}",
                    inline=True
                )
            
            await ctx.send(embed=embed)
        else:
            embed = discord.Embed(
                title="‚ö†Ô∏è Bot Inativo",
                description="O bot est√° desativado no momento.",
                color=discord.Color.orange()
            )
            embed.add_field(
                name="Como ativar",
                value=self.get_activation_message(),
                inline=False
            )
            
            await ctx.send(embed=embed)

    # Interceptar todos os comandos para verificar se o bot est√° ativo
    @commands.Cog.listener()
    async def on_command(self, ctx):
        """Verifica se o bot est√° ativo antes de executar qualquer comando"""
        # Log para depura√ß√£o
        logger.info(f"Comando detectado: !{ctx.command.name} de {ctx.author.name}")
        
        # Permitir sempre os comandos relacionados √† ativa√ß√£o
        allowed_commands = ['ativar', 'status', 'ajuda', 'help']
        
        # Se o comando n√£o estiver na lista de permitidos e o bot estiver inativo, cancelar
        if ctx.command.name not in allowed_commands and not self.is_active:
            logger.info(f"Comando !{ctx.command.name} bloqueado - bot inativo")
            embed = discord.Embed(
                title="‚ö†Ô∏è Bot Inativo",
                description="O bot est√° desativado no momento.",
                color=discord.Color.orange()
            )
            embed.add_field(
                name="Como ativar",
                value=self.get_activation_message(),
                inline=False
            )
            
            await ctx.send(embed=embed)
            # Indicar que o comando n√£o deve prosseguir
            ctx.command.reset_cooldown(ctx)
            raise commands.CommandError("Bot inativo")
            
    # Adicionar listener para mensagens - depura√ß√£o e ativa√ß√£o especial
    @commands.Cog.listener()
    async def on_message(self, message):
        """Monitora mensagens para depura√ß√£o e ativa o bot com palavras-chave espec√≠ficas"""
        # Ignorar mensagens do pr√≥prio bot
        if message.author == self.bot.user:
            return
            
        # Log apenas se a mensagem come√ßar com o prefixo de comando
        if message.content.startswith('!'):
            logger.info(f"Mensagem com prefixo '!' recebida: {message.content} de {message.author.name}")
            
        # Detectar palavras-chave para ativa√ß√£o sem prefixo
        content_lower = message.content.lower()
        if content_lower == "ativar" or content_lower == "ativar bot" or content_lower == "bot ativar" or "python ativar_bot.py" in content_lower:
            logger.info(f"Comando de ativa√ß√£o sem prefixo detectado: {message.content} de {message.author.name}")
            # Criar um contexto falso para passar para activate_bot
            ctx = await self.bot.get_context(message)
            await self.activate_bot(ctx)

    def load_settings(self):
        """Carrega as configura√ß√µes personalizadas do arquivo"""
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r') as f:
                    settings = json.load(f)
                    # Extrair a dura√ß√£o (em segundos) das configura√ß√µes
                    if 'duration' in settings:
                        self.activation_duration = settings['duration']
                        logger.info(f"Carregada dura√ß√£o personalizada: {self.activation_duration} segundos")
            else:
                # Se o arquivo n√£o existir, criar um com as configura√ß√µes padr√£o
                self.save_settings()
        except Exception as e:
            logger.error(f"Erro ao carregar configura√ß√µes: {e}")
            # Em caso de erro, usar a dura√ß√£o padr√£o
            self.activation_duration = self.default_duration
    
    def save_settings(self):
        """Salva as configura√ß√µes personalizadas no arquivo"""
        try:
            settings = {
                'duration': self.activation_duration
            }
            with open(self.settings_file, 'w') as f:
                json.dump(settings, f, indent=4)
            logger.info(f"Configura√ß√µes salvas: dura√ß√£o = {self.activation_duration} segundos")
        except Exception as e:
            logger.error(f"Erro ao salvar configura√ß√µes: {e}")
    
    @commands.command(name="definir_duracao")
    @commands.has_permissions(administrator=True)
    async def set_duration(self, ctx, horas: int):
        """Define a dura√ß√£o da ativa√ß√£o do bot (requer permiss√µes de administrador)"""
        if horas < 1 or horas > 12:
            await ctx.send("‚ö†Ô∏è A dura√ß√£o deve estar entre 1 e 12 horas.")
            return
        
        # Converter horas para segundos
        self.activation_duration = horas * 3600
        
        # Salvar a nova configura√ß√£o
        self.save_settings()
        
        # Informar o usu√°rio
        embed = discord.Embed(
            title="‚è±Ô∏è Dura√ß√£o Atualizada",
            description=f"A dura√ß√£o de ativa√ß√£o do bot foi alterada para {horas} hora{'s' if horas > 1 else ''}.",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Pr√≥xima ativa√ß√£o",
            value="Esta configura√ß√£o ser√° aplicada na pr√≥xima vez que o bot for ativado.",
            inline=False
        )
        if self.is_active:
            # Calcular tempo restante da ativa√ß√£o atual
            elapsed = (datetime.datetime.now() - self.activation_time).total_seconds()
            remaining = max(0, self.activation_duration - elapsed)
            hours, remainder = divmod(int(remaining), 3600)
            minutes, seconds = divmod(remainder, 60)
            
            time_str = ""
            if hours > 0:
                time_str += f"{hours} hora{'s' if hours > 1 else ''} "
            if minutes > 0 or hours > 0:
                time_str += f"{minutes} minuto{'s' if minutes != 1 else ''} "
            time_str += f"{seconds} segundo{'s' if seconds != 1 else ''}"
            
            embed.add_field(
                name="Ativa√ß√£o atual",
                value=f"O bot continuar√° ativo pelo tempo restante da ativa√ß√£o atual: {time_str}",
                inline=False
            )
        
        await ctx.send(embed=embed)
        logger.info(f"Dura√ß√£o de ativa√ß√£o alterada para {horas} horas por {ctx.author.name}")
        
    @set_duration.error
    async def set_duration_error(self, ctx, error):
        """Tratamento de erros para o comando definir_duracao"""
        if isinstance(error, commands.MissingPermissions):
            await ctx.send("‚õî Voc√™ precisa ter permiss√µes de administrador para alterar a dura√ß√£o de ativa√ß√£o.")
        elif isinstance(error, commands.MissingRequiredArgument):
            await ctx.send("‚ö†Ô∏è Uso correto: `!definir_duracao <horas>` (entre 1 e 12 horas)")
        elif isinstance(error, commands.BadArgument):
            await ctx.send("‚ö†Ô∏è O valor informado deve ser um n√∫mero inteiro de horas (entre 1 e 12)")
        else:
            await ctx.send(f"‚ùå Erro ao definir dura√ß√£o: {str(error)}")
            logger.error(f"Erro ao definir dura√ß√£o: {error}")

    def get_duration_display_text(self):
        """Retorna uma string formatada com a dura√ß√£o configurada"""
        duracao_horas = round(self.activation_duration / 3600)
        return f"{duracao_horas} hora{'s' if duracao_horas > 1 else ''}"
    
    def get_activation_message(self):
        """Retorna a mensagem para ativa√ß√£o do bot"""
        return f"Use o comando `!ativar` para ativar o bot por {self.get_duration_display_text()}."

async def setup(bot):
    """Adiciona o cog ao bot"""
    await bot.add_cog(Activation(bot))