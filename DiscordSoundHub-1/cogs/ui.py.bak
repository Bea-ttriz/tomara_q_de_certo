import discord
from discord.ext import commands
import asyncio
import logging
import database
import utils
from discord.ui import Button, View, Select

class AudioButton(Button):
    def __init__(self, audio, cog):
        emoji_value = None
        if audio.get('emoji') and len(audio.get('emoji').strip()) > 0:
            try:
                # Verificar se o emoji √© v√°lido
                emoji_value = audio.get('emoji').strip()
                # Se o emoji for uma string vazia ou None, n√£o usaremos emoji
                if not emoji_value:
                    emoji_value = None
            except Exception:
                emoji_value = None
        
        super().__init__(
            style=discord.ButtonStyle.primary,
            label=audio['nome'],
            emoji=emoji_value if emoji_value else "üéµ"
        )
        self.audio = audio
        self.cog = cog
    
    async def callback(self, interaction):
        # Criar um contexto fake para usar as fun√ß√µes existentes
        ctx = type('obj', (object,), {
            'guild': interaction.guild,
            'send': interaction.channel.send,
            'author': interaction.user
        })
        
        # Obter o cog de player
        player_cog = self.cog.bot.get_cog('Player')
        if player_cog:
            await player_cog.play_audio(ctx, audio_name=self.audio['nome'])
            await interaction.response.defer()
        else:
            await interaction.response.send_message("‚ùå Sistema de player n√£o dispon√≠vel.", ephemeral=True)

class AudioSelect(Select):
    def __init__(self, audios, cog):
        options = []
        
        # Agrupar por tipo
        originals = [a for a in audios if a['tipo'] == 'original']
        edited = [a for a in audios if a['tipo'] == 'editado']
        
        # Limitar a 25 op√ß√µes (limite do Discord)
        all_audios = (originals + edited)[:25]
        
        for audio in all_audios:
            emoji_value = None
            if audio.get('emoji') and len(audio.get('emoji').strip()) > 0:
                try:
                    # Verificar se o emoji √© v√°lido
                    emoji_value = audio.get('emoji').strip()
                    # Se o emoji for uma string vazia ou None, n√£o usaremos emoji
                    if not emoji_value:
                        emoji_value = None
                except Exception:
                    emoji_value = None
            
            option = discord.SelectOption(
                label=audio['nome'][:100],  # Discord limita a 100 caracteres
                value=audio['nome'],
                description=f"Tipo: {audio['tipo'].capitalize()}"
            )
            
            # Apenas adicionar emoji se for v√°lido
            if emoji_value:
                try:
                    option.emoji = emoji_value
                except Exception:
                    pass  # Ignorar emojis inv√°lidos
            
            options.append(option)
        
        super().__init__(
            placeholder="Selecione um √°udio para tocar...",
            options=options
        )
        self.cog = cog
    
    async def callback(self, interaction):
        selected_audio_name = self.values[0]
        
        # Criar um contexto fake para usar as fun√ß√µes existentes
        ctx = type('obj', (object,), {
            'guild': interaction.guild,
            'send': interaction.channel.send,
            'author': interaction.user
        })
        
        # Obter o cog de player
        player_cog = self.cog.bot.get_cog('Player')
        if player_cog:
            await player_cog.play_audio(ctx, audio_name=selected_audio_name)
            await interaction.response.defer()
        else:
            await interaction.response.send_message("‚ùå Sistema de player n√£o dispon√≠vel.", ephemeral=True)

class UI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.logger = logging.getLogger('discord_bot.ui')
    
    @commands.command(name="listar")
    async def list_audios(self, ctx):
        """Mostra todos os √°udios dispon√≠veis em um menu"""
        audios = database.get_all_audios()
        
        if not audios:
            await ctx.send("üìÇ N√£o h√° √°udios cadastrados. Use !upload para adicionar √°udios.")
            return
        
        # Cria√ß√£o do menu dropdown
        view = View(timeout=180)
        
        try:
            select = AudioSelect(audios, self)
            view.add_item(select)
        except Exception as e:
            self.logger.error(f"Erro ao criar menu dropdown: {e}")
            await ctx.send(f"‚ùå Erro ao criar menu: {e}")
            return
        
        # Adicionar bot√µes de navega√ß√£o
        originals_btn = Button(
            style=discord.ButtonStyle.secondary,
            label="Originais",
            emoji="üìÅ"
        )
        
        edited_btn = Button(
            style=discord.ButtonStyle.secondary,
            label="Editados",
            emoji="‚úÇÔ∏è"
        )
        
        all_btn = Button(
            style=discord.ButtonStyle.secondary,
            label="Todos",
            emoji="üîç"
        )
        
        async def show_originals(interaction):
            originals = [a for a in audios if a['tipo'] == 'original']
            if not originals:
                await interaction.response.send_message("üìÇ N√£o h√° √°udios originais cadastrados.", ephemeral=True)
                return
            
            embed = self.create_audio_list_embed("√Åudios Originais", originals)
            await interaction.response.send_message(embed=embed, ephemeral=True)
        
        async def show_edited(interaction):
            edited = [a for a in audios if a['tipo'] == 'editado']
            if not edited:
                await interaction.response.send_message("üìÇ N√£o h√° √°udios editados cadastrados.", ephemeral=True)
                return
            
            embed = self.create_audio_list_embed("√Åudios Editados", edited)
            await interaction.response.send_message(embed=embed, ephemeral=True)
        
        async def show_all(interaction):
            embed = self.create_audio_list_embed("Todos os √Åudios", audios)
            await interaction.response.send_message(embed=embed, ephemeral=True)
        
        originals_btn.callback = show_originals
        edited_btn.callback = show_edited
        all_btn.callback = show_all
        
        view.add_item(originals_btn)
        view.add_item(edited_btn)
        view.add_item(all_btn)
        
        # Mensagem principal
        embed = discord.Embed(
            title="üéµ Biblioteca de √Åudios - rivoTRIO",
            description=f"**{len(audios)}** √°udios dispon√≠veis\n\nSelecione um √°udio no menu abaixo para tocar, ou use os bot√µes para ver listas detalhadas.",
            color=discord.Color.blue()
        )
        
        # Contar por tipo
        originals_count = sum(1 for a in audios if a['tipo'] == 'original')
        edited_count = sum(1 for a in audios if a['tipo'] == 'editado')
        
        embed.add_field(name="üìÅ Originais", value=str(originals_count), inline=True)
        embed.add_field(name="‚úÇÔ∏è Editados", value=str(edited_count), inline=True)
        
        embed.set_footer(text="Use !ajuda para ver todos os comandos dispon√≠veis")
        await ctx.send(embed=embed, view=view)
    
    def create_audio_list_embed(self, title, audios):
        """Cria um embed com uma lista de √°udios"""
        embed = discord.Embed(
            title=f"üìã {title}",
            description=f"**{len(audios)}** √°udios encontrados",
            color=discord.Color.blue()
        )
        
        # Agrupar por tipo se for lista completa
        if title == "Todos os √Åudios":
            originals = [a for a in audios if a['tipo'] == 'original']
            edited = [a for a in audios if a['tipo'] == 'editado']
            
            if originals:
                safe_emojis = []
                for a in originals[:10]:
                    emoji = "üéµ"
                    if a.get('emoji') and len(a.get('emoji').strip()) > 0:
                        emoji = a.get('emoji').strip()
                    safe_emojis.append(f"{emoji} `{a['nome']}`")
                    
                originals_text = "\n".join(safe_emojis)
                if len(originals) > 10:
                    originals_text += f"\n... e mais {len(originals) - 10} √°udios."
                embed.add_field(name="üìÅ Originais", value=originals_text, inline=False)
            
            if edited:
                safe_emojis = []
                for a in edited[:10]:
                    emoji = "‚úÇÔ∏è" 
                    if a.get('emoji') and len(a.get('emoji').strip()) > 0:
                        emoji = a.get('emoji').strip()
                    safe_emojis.append(f"{emoji} `{a['nome']}`")
                    
                edited_text = "\n".join(safe_emojis)
                if len(edited) > 10:
                    edited_text += f"\n... e mais {len(edited) - 10} √°udios."
                embed.add_field(name="‚úÇÔ∏è Editados", value=edited_text, inline=False)
        else:
            # Lista simples para um tipo espec√≠fico
            audio_list = []
            for a in audios[:20]:
                emoji = "üéµ" 
                if a.get('emoji') and len(a.get('emoji').strip()) > 0:
                    emoji = a.get('emoji').strip()
                audio_list.append(f"{emoji} `{a['nome']}`")
                
            if len(audios) > 20:
                audio_list.append(f"... e mais {len(audios) - 20} √°udios.")
            
            embed.description += "\n\n" + "\n".join(audio_list)
        
        embed.set_footer(text="Use !tocar <nome> para reproduzir um √°udio")
        return embed
    
    @commands.command(name="carousel")
    async def carousel(self, ctx):
        """Mostra um carrossel interativo de √°udios"""
        audios = database.get_all_audios()
        
        if not audios:
            await ctx.send("üìÇ N√£o h√° √°udios cadastrados. Use !upload para adicionar √°udios.")
            return
        
        # Dividir em p√°ginas de 5 √°udios
        page_size = 5
        pages = [audios[i:i+page_size] for i in range(0, len(audios), page_size)]
        current_page = 0
        
        # Fun√ß√£o para atualizar o carrossel
        async def update_carousel(page_num, interaction=None):
            nonlocal current_page
            current_page = page_num
            
            # Atualizar view e embed
            new_view = self.create_carousel_view(pages[page_num], page_num, len(pages), update_carousel)
            new_embed = self.create_carousel_embed(pages[page_num], page_num, len(pages))
            
            if interaction:
                await interaction.response.edit_message(embed=new_embed, view=new_view)
            else:
                await message.edit(embed=new_embed, view=new_view)
        
        # Criar view inicial
        view = self.create_carousel_view(pages[current_page], current_page, len(pages), update_carousel)
        
        # Mensagem inicial
        embed = self.create_carousel_embed(pages[current_page], current_page, len(pages))
        message = await ctx.send(embed=embed, view=view)
    
    def create_carousel_view(self, page_audios, page_num, total_pages, update_callback=None):
        """Cria uma view para o carrossel de √°udios"""
        view = View(timeout=180)
        
        # Adicionar bot√µes para cada √°udio da p√°gina
        for audio in page_audios:
            try:
                button = AudioButton(audio, self)
                view.add_item(button)
            except Exception as e:
                self.logger.error(f"Erro ao criar bot√£o para √°udio {audio['nome']}: {e}")
                # Continuar com os pr√≥ximos bot√µes mesmo se um falhar
        
        # Adicionar bot√µes de navega√ß√£o se houver mais de uma p√°gina
        if total_pages > 1:
            nav_row = []
            
            # Bot√£o Anterior
            prev_button = Button(
                style=discord.ButtonStyle.secondary,
                emoji="‚¨ÖÔ∏è",
                disabled=(page_num == 0)
            )
            if update_callback:
                prev_button.callback = lambda i: update_callback(page_num - 1, i)
            nav_row.append(prev_button)
            
            # Indicador de p√°gina
            page_indicator = Button(
                style=discord.ButtonStyle.secondary,
                label=f"P√°gina {page_num + 1}/{total_pages}",
                disabled=True
            )
            nav_row.append(page_indicator)
            
            # Bot√£o Pr√≥ximo
            next_button = Button(
                style=discord.ButtonStyle.secondary,
                emoji="‚û°Ô∏è",
                disabled=(page_num == total_pages - 1)
            )
            if update_callback:
                next_button.callback = lambda i: update_callback(page_num + 1, i)
            nav_row.append(next_button)
            
            # Adicionar bot√µes de navega√ß√£o
            for button in nav_row:
                view.add_item(button)
        
        return view
    
    def create_carousel_embed(self, page_audios, page_num, total_pages):
        """Cria um embed para o carrossel de √°udios"""
        embed = discord.Embed(
            title="üéµ Carrossel de √Åudios - rivoTRIO",
            description=f"Clique nos bot√µes abaixo para reproduzir os √°udios. P√°gina {page_num + 1} de {total_pages}.",
            color=discord.Color.blue()
        )
        
        # Listagem dos √°udios na p√°gina atual
        for i, audio in enumerate(page_audios):
            emoji = "üéµ"
            if audio.get('emoji') and len(audio.get('emoji').strip()) > 0:
                emoji = audio.get('emoji').strip()
                
            duration = utils.format_duration(audio.get('duracao', 0))
            embed.add_field(
                name=f"{i+1}. {emoji} {audio['nome']}",
                value=f"Tipo: {audio['tipo'].capitalize()} ‚Ä¢ Dura√ß√£o: {duration}",
                inline=False
            )
        
        embed.set_footer(text="Use os bot√µes de navega√ß√£o para ver mais √°udios")
        return embed

async def setup(bot):
    await bot.add_cog(UI(bot))